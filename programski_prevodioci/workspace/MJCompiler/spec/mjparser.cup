package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, PRINT, VOID, CONST, NEW, READ;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL;
terminal INC, DEC, SEMI, COMMA;
terminal LPARENT, RPARENT, RBRACKET, LBRACKET, LBRACE, RBRACE;
terminal ENUM, DOT;

terminal RETURN;

terminal String IDENT ;
terminal Integer NUM_CONST ;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;


nonterminal Program, Declarations, DeclarationList;

nonterminal  TypeConst;
nonterminal ConstDecl, ConstElem, SingleConstElem;
nonterminal GlobVarDecl, GlobVarElem, GlobSingleVarElem;
nonterminal EnumDecl,  EnumElem, EnumSingleElem;

nonterminal  MethodDeclList, MethodDecl;
nonterminal FormPars, FormParam;
nonterminal VarDeclList;
nonterminal StmtList, Stmt; 
nonterminal DesignatorStmt, Designator, DesignatorIdentity;
nonterminal Expr;
nonterminal EnumIdent, EnumValue;
nonterminal Term, Factor;
nonterminal Addop, Mullop;

nonterminal ProgName;


//nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName; 
//nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, VarDeclList; 

Program ::= (Program) PROG ProgName Declarations:decl LBRACE MethodDeclList:methodDec RBRACE;

ProgName ::= (ProgName) IDENT:progName;

Declarations ::= (Declarations1) Declarations DeclarationList
				|(NoDeclarations) /*epsilon*/
				;

DeclarationList ::= (DeclarationsConstDecl) ConstDecl 
				 | (DeclarationsGlobVarDecl) GlobVarDecl
				 | (DeclarationsEnumDecl)EnumDecl
				 ;
				 
ConstDecl::= (ConstDeclaration)CONST IDENT:constType ConstElem SEMI;


ConstElem ::= (SingleConstElemDecl)SingleConstElem
			 | (ManyConstElemDecl)ConstElem COMMA SingleConstElem
			 ;
			
SingleConstElem ::= (SingleConstElem)IDENT:constName EQUAL TypeConst;



TypeConst ::= (NumberConst)NUM_CONST :value
			 | (BooleanConst)BOOL_CONST:value
			 | (CharacterConst)CHAR_CONST:value
			 ;
			 
GlobVarDecl ::= (GlobVarDecl) IDENT:varType GlobVarElem SEMI;


GlobVarElem ::= (GlobSingleVarElement) GlobSingleVarElem
			  | (ManyGlobVarElements)GlobVarElem COMMA GlobSingleVarElem
			  ;

GlobSingleVarElem ::= (GlobVarSingleDefWithoutBracket)IDENT:varName
				 | (GlobVarSingleDefWithBracket)IDENT:varName LBRACKET RBRACKET
				 ;

EnumDecl ::=(EnumDecl) ENUM IDENT:enumDeclName LBRACE EnumElem RBRACE;


EnumElem ::=(EnumSingleElement) EnumSingleElem
		   | (EnumManyElements)EnumElem COMMA EnumSingleElem
		   ;
		   
EnumSingleElem ::= (EnumSingleDefDefault)IDENT:enumName
				 | (EnumSingleDef)IDENT:enumName EQUAL NUM_CONST
				 ;  			 

MethodDeclList ::= (MethodDeclList1)MethodDeclList MethodDecl
				 |(NoMethodDecl) /*epsilon*/
				  ;	
				   
MethodDecl ::= (MethodDeclWithFormPars) IDENT :retType IDENT:methodName LPARENT FormPars RPARENT VarDeclList LBRACE StmtList RBRACE
			|(MethodDeclVoidWithFormPars) VOID:retType IDENT:methodName LPARENT FormPars RPARENT VarDeclList LBRACE StmtList RBRACE
			 | (MethodDeclWithoutFormPars)IDENT :retType IDENT LPARENT RPARENT VarDeclList LBRACE StmtList RBRACE
			 | (MethodDeclVoidWithoutFormPars)VOID:retType IDENT LPARENT RPARENT VarDeclList LBRACE StmtList RBRACE
			 ;

				  
FormPars ::= (FormalParameterOne) FormParam
		    | (FormalParametersMany) FormPars COMMA FormParam
		    ;

FormParam ::= (FormalParamDef)IDENT:typeName IDENT
			| (FormalParamArrayDef)IDENT:typeName IDENT LBRACKET RBRACKET
			;

VarDeclList ::= (VarDeclarationList) GlobVarDecl 
			| (NoVarDeclarationList)/*epsilon*/
			;
		

StmtList ::= (Statements)StmtList Stmt
		   | (NoStatements)/*epsilon*/
		   ;

Stmt ::=(Assignment) DesignatorStmt SEMI
		| (ReadStatement)READ LPARENT Designator RPARENT SEMI
		| (PrintStatementTwoArg)PRINT LPARENT Expr RPARENT SEMI 
		| (PrintStatementOneArg)PRINT LPARENT Expr COMMA NUM_CONST RPARENT SEMI
		;

DesignatorStmt ::= (DesignatorStmtAssign)Designator:dest EQUAL Expr:e
				 | (DesignatorStmtINC)Designator INC
				 | (DesignatorStmtDEc)Designator DEC
				 ;
				 
Designator ::= (DesignatorSingle) IDENT:name
			 |	(DesinatorWithDOT)EnumIdent DOT EnumValue 
			 | 	(DesignatorWithExpr)DesignatorIdentity LBRACKET Expr RBRACKET
			 ;		
			 
DesignatorIdentity ::= (DesignatorName) IDENT:designatorName;			 
			 
EnumIdent ::= (EnumIdentity)IDENT:identity;

EnumValue ::= (EnumValue)IDENT:identity;			 
	
Expr ::=	(ExprTerm)Term
			|
			(ExprMinusTerm)MINUS Term
			|
			(ExprList)Expr Addop Term
			;

Term ::= (TermSingleFactor) Factor 
		| (TermManyFactors)Term Mullop Factor
		;

Factor ::= (FactorConst)TypeConst
		 | (FactorNewArray)NEW IDENT LBRACKET Expr RBRACKET
		 | (FactorNew)NEW IDENT
		 | (FactorRegularExpr)LPARENT Expr RPARENT
		 ;
		 

Addop ::= (AddOperationPlus)PLUS
		| (AddOperationMinus)MINUS
		;
		
Mullop ::=(MultiplyOpTimes) MUL
		 | (MultiplyOpDivide)DIV
		 | (MultiplyOpMod)MOD
		 ;

				 