package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


///////////////////////////////////////////
terminal PROG, PRINT, RETURN, VOID, CONST, NEW, READ;
terminal DO, WHILE, FOR, EXTENDS, CONTINUE, BREAK, CLASS, INTERFACE;
terminal PLUS, MINUS, MUL, DIV, MOD, IS_EQ, IS_NOT_EQ, EQUALS;
terminal LARGER, LARGER_OR_EQ, LESSER, LESSER_OR_EQ;
terminal AND, OR, EQUAL, INC, DEC, SEMI, COMMA;
terminal LPARENT, RPARENT, RBRACKET, LBRACKET, LBRACE, RBRACE;
terminal IF, ELSE;
terminal ENUM, DOT;

terminal String IDENT ;
terminal Integer NUM_CONST ;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;


nonterminal Program, Declarations, DeclarationList;
nonterminal Type, TypeConst;
nonterminal ConstDecl, ConstElem, SingleConstElem;
nonterminal EnumDecl, EnumElem, EnumSingleElem;
nonterminal GlobVarDecl, GlobVarElem, GlobSingleVarElem;
nonterminal EnumDecl, EnumElem, SingleEnumElem;
nonterminal OptionMethodDecl, MethodDecl, MethodTypeName;
nonterminal FormPars, FormParam;
nonterminal VarDecl, VarElem, SingleVarElem;
nonterminal StmtList, Stmt; 
nonterminal DesignatorStmt, Designator;
nonterminal Expr, ExprList;
nonterminal Term, Factor;
nonterminal Addop, Mullop;


//nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName; 
//nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, VarDeclList; 

Program ::=  PROG IDENT Declarations LBRACE OptionMethodDecl RBRACE;

Declarations ::= Declarations DeclarationList
				| /*epsilon*/;

DeclarationList::= ConstDecl 
				 | GlobVarDecl
				 | EnumDecl
				 //| ClassDecl
				// | InterfaceDecl;
				 
ConstDecl::= CONST Type ConstElem SEMI;

ConstElem ::= SingleConstElem
			 | ConstElem COMA SingleConstElem;
			
SingleConstElem ::= IDENT
				   | IDENT EQUAL TypeConst
				   | IDENT LBRACKET RBRACKET;

Type ::= IDENT;


TypeConst ::= NUM_CONST
			 | BOOL_CONST
			 | CHAR_CONST;
			 
GlobVarDecl ::= Type GlobVarElem SEMI;

GlobVarElem ::=  GlobSingleVarElem
			| GlobVarElem COMA GlobsSingleVarElem;

GlobSingleVarElem ::= IDENT
				 | IDENT LBRACKET RBRACKET;

EnumDecl ::= ENUM IDENT LBRACE EnumElem RBRACE;

EnumElem ::= EnumSingleElem
		   | EnumElem COMA EnumSingleElem;
		   
EnumSingleElem ::= IDENT
				 | IDENT EQUALS NUM_CONST;  			 

OptionMethodDecl ::= MethodDecl
				   | /*epsilon*/;
				   
//2 slucaja-jedan fja bez arg, drugi fja sa argumentima
MethodDecl ::= MethodTypeName IDENT LPARENT FormPars RPARENT VarDecl LBRACE StmtList RBRACE
			 | MethodTypeName IDENT LPARENT RPARENT VarDecl LBRACE StmtList RBRACE;
			 
MethodTypeName ::= Type
				  | VOID;
				  
//ne moze da bude prazno jer je to vec razdeljeno
FormPars ::= FormParam
		    | FormPars COMA FormParam;

FormParam ::= Type IDENT
			| Type IDENT LBRACKET RBRACKET;


VarDecl ::= VarDecl VarElem
		  | /*epsilon*/;

VarElem ::= Type SingleVarElem SEMI;

//proveriti da li se ovim lokalnim parametrima moze dodeliti pocetna vrednost
//ako ne moze, onda je ovo ok
SingleVarElem ::= IDENT
				| IDENT LBRACKET RBRACKET;
		
//stmt moze da obuhvata vise redova, a moze i da ga ne bude
//ukoliko ga ima, moze da bude 1 i vise
//za nivo A je moguce sa Designator , sa read i 2 mogucnosti sa PRINT	

StmtList ::=StmtList Stmt
		   | /*epsilon*/

Stmt ::= DesignatorStmt SEMI
		| READ LPARENT Designator RPARENT SEMI
		| PRINT LPARENT Expr RPARENT SEMI //print with one argument
		| PRINT LPARENT Expr COMA NUM_CONST RPARENT SEMI;

DesignatorStmt ::= Designator EQUALS Expr
				 | Designator INC
				 | Designator DEC;
				 
Designator ::= IDENT DOT IDENT //ident.ident samo za nabrajanja
			 | IDENT LBRACKET Expr RBRACKET;			
			 
Expr ::= MINUS ExpressionList
	   | ExpressionList;
	
ExpressionList ::=	Term
				 | 	ExprList Addop Term	

//Term ima bar jedan Factor i zatim mogu da se ponavljaju {Mullop Factor}   
Term ::= Factor 
		| Term Mullop Factor;

Factor ::= TypeConst
		 | NEW IDENT
		 | LPARENT Expr RPARENT
		 | LBRACKET Expr RBRACKET;
		 

*Addop ::= PLUS
		| MINUS;
		
*Mullop ::= MUL
		 | DIV
		 | MOD;

				 